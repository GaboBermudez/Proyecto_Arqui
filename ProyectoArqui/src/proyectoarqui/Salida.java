/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectoarqui;


import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.Semaphore;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.SwingWorker;

/**
 *
 * @author b10141
 */
public class Salida extends javax.swing.JFrame{

    /**
     * Creates new form Salida
     */
    public Salida() {
        initComponents();
        //simulacion = laSimulacion;
    }
    
    ProyectoArqui simulacion;
    
    public void refrescar(){
        registrosN1.revalidate();
        registrosN2.revalidate();
        registrosN1.repaint();
        registrosN2.repaint();
    }
  /*  
    public void setMemoriaInstrucciones(int[] instrucciones){
        int j;
        for(int i = 0;i<instrucciones.length;++i){
            j=i;
                memoriaInstrucciones.setValueAt(instrucciones[i],(i%16), j);
                if(j%16==0){
                    j=0;
                }
            }    
    }
    */
    public static void setMemoriaInstrucciones(int[] instrucciones){
        int n = 0;
        for(int j = 0; j < 40; ++j){
            for(int i = 0; i < 16; ++i,++n){
                memoriaInstrucciones_view.setValueAt(instrucciones[n], j, i);
                //System.out.print(""+instrucciones[n]);
            }
            //System.out.println();
        }
        memoriaInstrucciones_view.repaint();
    }
    /**
     * Refresca los registros de el nucleo
     * @param reg
     * @param nucleo 
     */
    public void setRegistros(int[] reg, int nucleo){
        if( nucleo == 0){
            for(int i =0;i<reg.length;++i){
                registrosN1.setValueAt(reg[i],i, 1);
            }    
        }
        else{
            for(int i =0;i<reg.length;++i){
                registrosN2.setValueAt(reg[i],i, 1);
            }  
        }
    }
    
    public void setCaches(int[][] cache, int nucleo ){
        if(nucleo ==0){
            for(int i =0;i<cache.length;++i){
                for(int j=0; j<cache[i].length;++j){
                    CacheN1.setValueAt(cache[i][j],j,i);
                }
            }
            
        }
        else{
            for(int i =0;i<cache.length;++i){
                for(int j=0; j<cache[i].length;++j){
                    CacheN2.setValueAt(cache[i][j],j,i);
                }
            }
        }
    }
    
    public void setReloj(int reloj){
        Reloj.setText(Integer.toString(reloj));
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        Reloj = new javax.swing.JLabel();
        labelReloj = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        CacheN1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        CacheN2 = new javax.swing.JTable();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        registrosN1 = new javax.swing.JTable();
        jScrollPane4 = new javax.swing.JScrollPane();
        registrosN2 = new javax.swing.JTable();
        jScrollPane5 = new javax.swing.JScrollPane();
        memoriaInstrucciones_view = new javax.swing.JTable();
        jLabel3 = new javax.swing.JLabel();
        bus = new javax.swing.JTextField();
        labelBus = new javax.swing.JLabel();
        Avanzar = new javax.swing.JButton();
        jScrollPane6 = new javax.swing.JScrollPane();
        cacheDatosN1 = new javax.swing.JTable();
        jScrollPane7 = new javax.swing.JScrollPane();
        cacheDatosN2 = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        Reloj.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        Reloj.setText("00");
        Reloj.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        Reloj.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        labelReloj.setText("Reloj");

        CacheN1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "0", "1", "2", "3", "4", "5", "6", "7"
            }
        ));
        jScrollPane1.setViewportView(CacheN1);

        jLabel1.setText("Nucleo 1");

        CacheN2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "0", "1", "2", "3", "4", "5", "6", "7"
            }
        ));
        jScrollPane2.setViewportView(CacheN2);

        jLabel2.setText("Nucleo 2");

        registrosN1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"0", null},
                {"1", null},
                {"2", null},
                {"3", null},
                {"4", null},
                {"5", null},
                {"6", null},
                {"7", null},
                {"8", null},
                {"9", null},
                {"10", null},
                {"11", null},
                {"12", null},
                {"13", null},
                {"14", null},
                {"15", null},
                {"16", null},
                {"17", null},
                {"18", null},
                {"19", null},
                {"20", null},
                {"21", null},
                {"22", null},
                {"23", null},
                {"24", null},
                {"25", null},
                {"26", null},
                {"27", null},
                {"28", null},
                {"29", null},
                {"30", null},
                {"31", null}
            },
            new String [] {
                "Reg", ""
            }
        ));
        jScrollPane3.setViewportView(registrosN1);

        registrosN2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null}
            },
            new String [] {
                "Reg", ""
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Integer.class, java.lang.Object.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane4.setViewportView(registrosN2);

        memoriaInstrucciones_view.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""
            }
        ));
        jScrollPane5.setViewportView(memoriaInstrucciones_view);

        jLabel3.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel3.setText("Memoria de Instrucciones");

        labelBus.setText("Estado de bus");

        Avanzar.setText("Avanzar");
        Avanzar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AvanzarActionPerformed(evt);
            }
        });

        cacheDatosN1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "1", "2", "3", "4", "5", "6", "7", "8"
            }
        ));
        jScrollPane6.setViewportView(cacheDatosN1);

        cacheDatosN2.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "1", "2", "3", "4", "5", "6", "7", "8"
            }
        ));
        jScrollPane7.setViewportView(cacheDatosN2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(32, 32, 32)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jLabel3)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(17, 17, 17)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                    .addComponent(labelReloj, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                    .addComponent(Reloj, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(436, 436, 436)
                                                .addComponent(bus, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                    .addComponent(Avanzar, javax.swing.GroupLayout.Alignment.TRAILING)
                                                    .addComponent(labelBus, javax.swing.GroupLayout.Alignment.TRAILING))))
                                        .addGap(57, 57, 57)))))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel2))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(55, 55, 55)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 323, Short.MAX_VALUE)
                                    .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                                .addGap(26, 26, 26)
                                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(0, 0, Short.MAX_VALUE)))
                        .addGap(23, 23, 23))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 218, Short.MAX_VALUE)
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 912, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(182, 182, 182))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(labelReloj, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Reloj)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel1)
                        .addComponent(Avanzar)))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 547, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 547, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(140, 140, 140)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(37, 37, 37)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(11, 11, 11)
                        .addComponent(labelBus)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(bus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(135, 135, 135)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 230, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(14, Short.MAX_VALUE))
        );

        labelReloj.getAccessibleContext().setAccessibleParent(labelReloj);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void AvanzarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AvanzarActionPerformed
        avanzaReloj = true;
    }//GEN-LAST:event_AvanzarActionPerformed
    
    public boolean getAvanzaReloj(){
        return avanzaReloj;
    }
    
    private boolean avanzaReloj = false;
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Salida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Salida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Salida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Salida.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
               //new Salida(simulacion).setVisible(true);
               // simulacion.run();
               //int m,b,quantum;

                ProyectoArqui simulacion = new ProyectoArqui(2, 2, 2, "C:\\Users\\Ricardo Aguilar\\Desktop\\HILOS 1ERA PARTE - V4");
                //this.setVisible(true);
                Salida interfaz = new Salida();
                interfaz.setVisible(true);
                simulacion.execute();
            }
        });
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Avanzar;
    private static javax.swing.JTable CacheN1;
    private static javax.swing.JTable CacheN2;
    private static javax.swing.JLabel Reloj;
    private static javax.swing.JTextField bus;
    private javax.swing.JTable cacheDatosN1;
    private javax.swing.JTable cacheDatosN2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JLabel labelBus;
    private javax.swing.JLabel labelReloj;
    private static javax.swing.JTable memoriaInstrucciones_view;
    private static javax.swing.JTable registrosN1;
    private static javax.swing.JTable registrosN2;
    // End of variables declaration//GEN-END:variables


    /**
     *
     * @author gabobermudez
     */
    private static class ProyectoArqui extends SwingWorker<Void,Integer>{
                // Esto es todo lo que se comparte
        boolean modoLento = false;
        private final ExecutorService pool;
        public static Semaphore bus = new Semaphore(1);
        public static Semaphore busDatos = new Semaphore(1);
        public static Semaphore s_cacheDatosNucleo1 = new Semaphore(1);
        public static Semaphore s_cacheDatosNucleo2 = new Semaphore(1);
        public static Semaphore procesos = new Semaphore(1);
        public static int[] memoriaInstrucciones = new int[640];
        public static int[] memoriaDatos = new int [1408];
        public static CyclicBarrier barrier = new CyclicBarrier(3);
        public static int[] vectorPCs = new int[2];
        public static int clock;
        public static LinkedList<BloqueAInvalidar> bloquesAInvalidar = new LinkedList<>();
        public static String path;
        public static boolean estaOcupadoN1;
        public static boolean estaOcupadoN2;
        public static int[][] cacheInstruccionesNucleo1 = new int [8][17];
        public static int[][] cacheDatosNucleo1 = new int [6][8];
        public static int[][] cacheInstruccionesNucleo2 = new int [8][17];
        public static int[][] cacheDatosNucleo2 = new int [6][8];
        public static int[] registrosNucleo1 = new int [32];
        public static int[] registrosNucleo2 = new int [32];
        public static int QuantumIngresado;
        private static int PCN1;
        private static int IRN1;
        private static int PCN2;
        private static int IRN2;
        private static int hiloN1;
        private static int hiloN2;
        private static int ProcessIDN1;
        private static int ProcessIDN2;
        private static Queue<Contexto> colaContextos = new LinkedList<>();
        private static Queue<Integer> colaProcesos = new LinkedList<>();
        public static int m;
        public static int b;


        

        public ProyectoArqui(int quantum, int m, int b, String path){
            QuantumIngresado = quantum;
            this.m = m;
            this.b = b;
            this.path = path;
            pool = Executors.newFixedThreadPool(2);
        }


        private static class BloqueAInvalidar{
            private int bloque;
            private int cache;
            
            public BloqueAInvalidar(int elBloque, int laCache) {
               this.bloque = elBloque;
               this.cache = laCache;
            }
            
            public int getCache(){
                return this.cache;
            }
            public int getBloque(){
                return this.bloque;
            }
            
            public void setCache(int laCache){
                this.cache = laCache;
            }
            public void setBloque (int elBloque){
                this.bloque = elBloque;
            }
            
             
       }
        
        
        private static class Contexto {
            private int numHilo;
            private int PC;
            private int[] registros = new int[32];

            public Contexto(int[] registros, int PC, int hiloID){
                this.PC = PC;
                System.arraycopy(registros, 0, this.registros, 0, 32);
                this.numHilo = hiloID;
            }

            public int getPC(){
                return this.PC;
            }

            public int getNumHilo(){
                return this.numHilo;
            }


            public void setNumHilo(int hiloID){
                this.numHilo = hiloID;
            }

            public int[] getRegistros(){
                return this.registros;
            }
        }


        /**
         * Carga todos los archivos de instrucciones a la memoria de instrucciones 
         * compartida por los dos nucleos
         */
        public static void cargarMemoriaInstrucciones(){

            int bloqueMemoria = 0;
            int PC = 0;
            for(int i = 1; i <= 6; ++i){
                try {
                Path filePath = Paths.get(path+"/"+i+".txt");
                Scanner scanner = new Scanner(filePath);
                List<Integer> instrucciones = new ArrayList<>();
                while (scanner.hasNext()) {
                    if (scanner.hasNextInt()) {
                        instrucciones.add(scanner.nextInt());
                    } else {
                    scanner.next();
                  }
                }

                String palabra = "";
                for(int ins : instrucciones){
                    palabra +=+ins+" ";
                    if(((bloqueMemoria+1)%4)==0){
                      //  System.out.println("palabra " + palabra);
                        palabra = "";
                    }
                    memoriaInstrucciones[bloqueMemoria] = ins;
                    ++bloqueMemoria;
                }

                } catch (IOException ex) {
                    Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                }
                int[] reg = new int[32];
                Arrays.fill(reg,0);
                Contexto contexto = new Contexto(reg, PC,i);
               // System.out.println("PC contexto "+i+": "+bloqueMemoria);
                colaContextos.add(contexto);
                colaProcesos.add(i);
                PC = bloqueMemoria;
            }


            for(int i =0 ; i < memoriaInstrucciones.length; ++i){
                System.out.print(memoriaInstrucciones[i]+" ");
                if(i%16 == 0 && i!=0 ){System.out.println();}
            }
            System.out.println();
            
            //Actualiza la GUI
            //setMemoriaInstrucciones(memoriaInstrucciones);

        }

        /**
         * Inicializa los nucleos para la primer corrida
         */
        public static void iniciarNucleos(){
            //Carga Nucleo 1
            Contexto contextoNucleo1 = colaContextos.poll();
            PCN1 = contextoNucleo1.getPC();
            hiloN1 = contextoNucleo1.getNumHilo();
            //System.out.println("PC Nucleo 1: "+Integer.toString(contextoNucleo1.getPC()));
            System.arraycopy(contextoNucleo1.getRegistros(), 0, registrosNucleo1, 0, 32);
            for(int j = 0; j<8; ++j){
                cacheInstruccionesNucleo1[j][16] = -1;
            }
            estaOcupadoN1=true;

            ///Preguntar si hay mas hilos
            //Carga Nucleo 2
            Contexto contextoNucleo2 = colaContextos.poll();
            PCN2 = contextoNucleo2.getPC();
            hiloN2 = contextoNucleo2.getNumHilo();
            //System.out.println("PC Nucleo 2: "+Integer.toString(contextoNucleo2.getPC()));
            System.arraycopy(contextoNucleo2.getRegistros(), 0, registrosNucleo1, 0, 32);
            for(int j = 0; j<8; ++j){
                cacheInstruccionesNucleo2[j][16] = -1;
            }
            estaOcupadoN2 = true;
        }


        /**
         * Barrera para poder sincronizar el paso de ciclo de reloj
         * @throws InterruptedException
         * @throws BrokenBarrierException 
         */
        public static void  barrera() throws InterruptedException, BrokenBarrierException{
            barrier.await();
        }

        /**
         * Verifica si hay hilos en cola
         * @return 
         */
        public static boolean hayHilosEnCola(){
            boolean hay = true;
                if(colaContextos.isEmpty()){
                    hay = false;
                }
            return hay;
        }

        /**
         * 
         * @param nucleo nucleo al que se le va enviar el siguiente hilo
         */
        public static void traerSiguenteHilo(int nucleo){
            if (nucleo == 0){ //Nucleo 1
                Contexto contextoNuevo = colaContextos.poll();
                PCN1 = contextoNuevo.getPC();
                System.arraycopy(contextoNuevo.getRegistros(), 0, registrosNucleo1, 0, 32);
            }
            else { //Nucleo 2
                Contexto contextoNuevo = colaContextos.poll();
                PCN2 = contextoNuevo.getPC();
                System.arraycopy(contextoNuevo.getRegistros(), 0, registrosNucleo2, 0, 32);
            }
            try {
                barrera();
            } catch (InterruptedException | BrokenBarrierException ex) {
                Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        /*
            Invalida los bloques en medio de los ciclos de reloj para que esten invalidos a partir del proximo ciclo de reloj.
        
        */
        public static void invalidarBloques(){
            while(!bloquesAInvalidar.isEmpty()){
                BloqueAInvalidar bloque_temp = bloquesAInvalidar.poll();
                int cache = bloque_temp.getCache();
                int bloque = bloque_temp.getBloque()%8;
                int bloque_mem = bloque_temp.getBloque();
                if(cache == 0){ //Es la cache de datos del nucleo 1
                    if(cacheDatosNucleo1[bloque][4] == bloque_mem)
                        cacheDatosNucleo1[bloque][5] = -1;
                }
                else { //Es la cache de datos del nucleo 2
                    if(cacheDatosNucleo2[bloque][4] == bloque_mem)
                        cacheDatosNucleo2[bloque][5] = -1;
                }
            }
        }
        
        /**
         * obtiene el cache correspondiente a el nucleo que lo llamo
         * @param nucleo numero de hilo que lo invoco
         * @return la cache en forma de string
         */
        public static String obtenerCache( int nucleo){
            String str ="";
            str+="Imprimiendo Cache\n";
            if(nucleo ==0 ){
                for(int i=0; i<cacheInstruccionesNucleo1.length; ++i){
                    for(int j=0; j<cacheInstruccionesNucleo1[i].length;++j){
                        str+=""+cacheInstruccionesNucleo1[i][j]+" ";
                    }
                    str+="\n";
                }
            }
            else{
                for(int i=0; i<cacheInstruccionesNucleo2.length; ++i){
                    for(int j=0; j<cacheInstruccionesNucleo2[i].length;++j){
                        str+=""+cacheInstruccionesNucleo2[i][j]+" ";
                    }
                    str+="\n";
                }
            }
            return str;
        }

        
        /**
         * 
         * @param nucleo nucleo al que se le acabo el Quantum
         */
        public static synchronized void cambioDeContexto(int nucleo){
            if (nucleo == 0){ //Nucleo 1
                Contexto contexto = new Contexto(registrosNucleo1,PCN1,hiloN1);
                colaContextos.add(contexto);
                colaProcesos.add(ProcessIDN1);
                //System.out.println("PC A GUARDAR NUCLEO1 "+PCN1);
                Contexto contextoNuevo = colaContextos.poll();
                PCN1 = contextoNuevo.getPC();
                System.arraycopy(contextoNuevo.getRegistros(), 0, registrosNucleo1, 0, 32);
                //System.out.println("PC EXTRAIDO NUCLEO1 "+PCN1);
            }
            else { //Nucleo 2
                Contexto contexto = new Contexto(registrosNucleo2,PCN2,hiloN2);
                colaContextos.add(contexto);
                colaProcesos.add(ProcessIDN2);
                //System.out.println("PC A GUARDAR NUCLEO2 "+PCN2);
                Contexto contextoNuevo = colaContextos.poll();
                PCN2 = contextoNuevo.getPC();
                System.arraycopy(contextoNuevo.getRegistros(), 0, registrosNucleo2, 0, 32);
               //System.out.println("PC EXTRAIDO NUCLEO2 "+PCN2);
            }
            try {
                barrera();
            } catch (InterruptedException | BrokenBarrierException ex) {
                Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
            }
        }


        


        @Override
        protected Void doInBackground() throws Exception {
            /**
         * Programa Principal
         * @param args
         * @throws IOException 
         */
            String rutaN1 = path+"/bitacoraNucleo1.txt";
            String rutaN2 = path+"/bitacoraNucleo2.txt";
            //m_salida.setVisible(true);


            File archivo1 = new File(rutaN1);
            File archivo2 = new File(rutaN2);

            BufferedWriter bw1 = new BufferedWriter(new FileWriter(archivo1));
            BufferedWriter bw2 = new BufferedWriter(new FileWriter(archivo2));
            PrintWriter escribir1 = new PrintWriter(bw1);//para crear el objeto que escribe en el archivo
            PrintWriter escribir2 = new PrintWriter(bw2);//para crear el objeto que escribe en el archivo
            clock = 0;                          


            cargarMemoriaInstrucciones();
            iniciarNucleos();

            for (int i = 0; i < 2; i++){
                pool.submit(new Thread (""+i){
                   private boolean estoyOcupado;
                    private int miQuantum;
                    private boolean finalizoHilo = false;

                    /**
                     * Verifica si un bloque esta en el cache
                     * @param etiqueta la etiqueta del bloque 
                     * @param nucleo el numero de nucleo dueño del cache
                     * @return 
                     */
                    private boolean estaEnCache( int etiqueta, int nucleo ){
                        boolean estaBloqueEnCache = false;
                        int bloque = etiqueta%8;
                        if(nucleo == 0 ){
                            //System.out.println("Buscando en cache N1 con la etiqueta "+etiqueta);
                            if(cacheInstruccionesNucleo1[bloque][16] == etiqueta ){
                                estaBloqueEnCache = true;
                             }
                        }
                        if(nucleo == 1){
                            //System.out.println("Buscando en cache N2 con la etiqueta "+etiqueta);
                            if(cacheInstruccionesNucleo2[bloque][16] == etiqueta ){
                                estaBloqueEnCache = true;
                             }
                        }
                        return estaBloqueEnCache;
                    }
                    
                    private boolean estaEnCacheDatos( int etiqueta, int nucleo ){
                        boolean estaBloqueEnCache = false;
                        int bloque = etiqueta%8;
                        if(nucleo == 0 ){
                            //System.out.println("Buscando en cache N1 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo1[bloque][4] == etiqueta && cacheDatosNucleo1[bloque][5] != -1){
                                estaBloqueEnCache = true;
                             }
                        }
                        if(nucleo == 1){
                            //System.out.println("Buscando en cache N2 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo2[bloque][4] == etiqueta && cacheDatosNucleo2[bloque][5] != -1){
                                estaBloqueEnCache = true;
                             }
                        }
                        return estaBloqueEnCache;
                    }
                    
                    private boolean estaModificado(int etiqueta, int nucleo){
                        boolean estaModificado = false;
                        int bloque = etiqueta%8;
                        if(nucleo == 0 ){
                            //System.out.println("Buscando en cache N1 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo1[bloque][5] == 2){
                                estaModificado = true;
                             }
                        }
                        if(nucleo == 1){
                            //System.out.println("Buscando en cache N2 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo2[bloque][5] == 2){
                                estaModificado = true;
                             }
                        }
                        return estaModificado;
                    }
                    
                    private boolean estaCompartido(int etiqueta, int nucleo){
                        boolean estaCompartido = false;
                        int bloque = etiqueta%8;
                        if(nucleo == 0 ){
                            //System.out.println("Buscando en cache N1 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo1[bloque][5] == 1){
                                estaCompartido = true;
                             }
                        }
                        if(nucleo == 1){
                            //System.out.println("Buscando en cache N2 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo2[bloque][5] == 1){
                                estaCompartido = true;
                             }
                        }
                        return estaCompartido;
                    }
                    
                    private boolean estaInvalido(int etiqueta, int nucleo){
                        boolean estaInvalido = false;
                        int bloque = etiqueta%8;
                        if(nucleo == 0 ){
                            //System.out.println("Buscando en cache N1 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo1[bloque][5] == -1){
                                estaInvalido = true;
                             }
                        }
                        if(nucleo == 1){
                            //System.out.println("Buscando en cache N2 con la etiqueta "+etiqueta);
                            if(cacheDatosNucleo2[bloque][5] == -1){
                                estaInvalido = true;
                             }
                        }
                        return estaInvalido;
                    }
                    
                    public void store(int numNucleo, int[]laInstruccion, int bloque){
                        int regAGuardar = laInstruccion[2];
                        
                        if (numNucleo == 0){ //Es Nucleo 1
                            int direccionMem = registrosNucleo1[laInstruccion[1]] + laInstruccion[3] + 640;
                            boolean termine = false;
                            //Pido mi cache
                            while(!termine){
                                if (s_cacheDatosNucleo1.tryAcquire()){
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    //Tengo mi cache y verifico si es un hit
                                    if (!estaEnCacheDatos(direccionMem, numNucleo)){
                                        //Si es un fallo, lo resuelvo
                                        if (resolverFalloCacheDatos(direccionMem, bloque, numNucleo)){
                                            //AQUI SE HACE EL STORE
                                        }

                                    }
                                    s_cacheDatosNucleo1.release(); 
                                }
                                else {
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                            }
                            
                        }
                        else { //Es Nucleo 2
                            
                            int direccionMem = registrosNucleo2[laInstruccion[1]] + laInstruccion[3] + 640;
                            boolean termine = false;
                            //Pido mi cache
                            while(!termine){
                                if (s_cacheDatosNucleo2.tryAcquire()){
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    //Tengo mi cache y verifico si es un hit
                                    if (!estaEnCacheDatos(direccionMem, numNucleo)){
                                        //Si es un fallo, lo resuelvo.
                                        if(resolverFalloCacheDatos(direccionMem, bloque, numNucleo)){
                                           //AQUI SE HACE EL STORE 
                                        }
                                        
                                    }
                                    s_cacheDatosNucleo2.release(); 
                                }
                                else {
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                            }
                            
                        }
                    }
                    
                    
                    public void load(int numNucleo, int[] laInstruccion, int bloque){
                        //FALTA COPIAR LA PALABRA AL REGISTRO. Hay que calcular el offset en el bloque para saber cual palabra.
                        /*                           INS| 0 | 1 | 2 | 3 |
                        LW RX, n(RY)| Rx <-- M(n + (Ry))| 35  Y   X   n
                        */
                        int regAGuardar = laInstruccion[2];
                        int numero_palabra=0;
                        
                        if (numNucleo == 0){ //Es Nucleo 1
                            int direccionMem = registrosNucleo1[laInstruccion[1]] + laInstruccion[3] + 640;
                            int numero_bloque = (direccionMem/4)%8;
                            numero_palabra = direccionMem%4;
                            boolean termine = false;
                            //Pido mi cache
                            while(!termine){
                                if (s_cacheDatosNucleo1.tryAcquire()){
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    //Tengo mi cache y verifico si es un hit
                                    if (!estaEnCacheDatos(direccionMem, numNucleo)){
                                        //Si es un fallo, lo resuelvo
                                        if (resolverFalloCacheDatos(direccionMem, bloque, numNucleo)){
                                            //AQUI SE HACE EL LOAD 
                                            int palabra = cacheDatosNucleo1[numero_bloque][numero_palabra];  
                                            registrosNucleo1[regAGuardar]= palabra ;
                                        }
                                            
                                    }else{
                                        if(estaModificado(numero_bloque, numNucleo)){
                                             int palabra = cacheDatosNucleo1[numero_bloque][numero_palabra];  
                                             registrosNucleo1[regAGuardar]= palabra ;
                                        }
                                        else{// si no, esta compartido
                                            BloqueAInvalidar m_bloque = new BloqueAInvalidar(numero_bloque,0);
                                             bloquesAInvalidar.add(m_bloque);
                                        }
                                    }
                       
                                    s_cacheDatosNucleo1.release(); 
                                }
                                else {
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                            }
                            
                        }
                        else { //Es Nucleo 2
                            int direccionMem = registrosNucleo2[laInstruccion[1]] + laInstruccion[3] + 640;
                            int numero_bloque = (direccionMem/4)%8;
                            numero_palabra = direccionMem%4;
                            boolean termine = false;
                            //Pido mi cache
                            while(!termine){
                                if (s_cacheDatosNucleo2.tryAcquire()){
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                    //Tengo mi cache y verifico si es un hit
                                   if (!estaEnCacheDatos(direccionMem, numNucleo)){
                                        //Si es un fallo, lo resuelvo
                                        if (resolverFalloCacheDatos(direccionMem, bloque, numNucleo)){
                                            //AQUI SE HACE EL LOAD 
                                            int palabra = cacheDatosNucleo1[numero_bloque][numero_palabra];  
                                            registrosNucleo1[regAGuardar]= palabra ;
                                        }
                                            
                                    }else{
                                        if(estaModificado(numero_bloque, numNucleo)){
                                             int palabra = cacheDatosNucleo2[numero_bloque][numero_palabra];  
                                             registrosNucleo2[regAGuardar]= palabra ;
                                        }
                                        else{// si no, esta compartido
                                            BloqueAInvalidar m_bloque = new BloqueAInvalidar(numero_bloque,1);
                                             bloquesAInvalidar.add(m_bloque);
                                        }
                                    }
                                    s_cacheDatosNucleo2.release(); 
                                }
                                else {
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                            }
                            
                        }
                    }
                    
                    /**
                     * 
                     * @param PC 
                     * @param etiqueta etiqueta para buscar en memoria
                     * @param nucleo  nucleo dueño del cache
                     */
                    public synchronized void resolverFalloCache(int PC, int etiqueta, int nucleo){
                    while(!bus.tryAcquire()){
                        System.out.println("Nucleo "+nucleo+" no tiene el bus");
                        try {
                            barrera();
                        } catch (InterruptedException | BrokenBarrierException ex) {
                            Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                    int i = etiqueta % 8;

                    int j = 0;

                    if (nucleo == 0){
                        System.out.println("FilaFalloCacheN1 "+i);
                        for(int n = etiqueta*16; n < (etiqueta*16)+16; n++,j++){
                            cacheInstruccionesNucleo1[i][j] = memoriaInstrucciones[n];
                            //System.out.print(memoriaInstrucciones[n]+" ");
                        }
                        cacheInstruccionesNucleo1[i][j] = etiqueta;
                    }
                    else if (nucleo == 1){
                        System.out.println("FilaFalloCacheN2 "+i);
                        for(int n = etiqueta*16; n < (etiqueta*16)+16; n++,j++){
                            cacheInstruccionesNucleo2[i][j] = memoriaInstrucciones[n];
                            //System.out.print(memoriaInstrucciones[n]+" ");
                        }
                        cacheInstruccionesNucleo2[i][j] = etiqueta;
                    }
                    System.out.println();
                    for(int k =0 ; k<(4*(b+m+b));++k){
                        try {
                            barrera();
                            barrera();
                        } catch (InterruptedException | BrokenBarrierException ex) {
                            Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                    bus.release();
                }
                    
                public synchronized boolean resolverFalloCacheDatos(int direccionMem, int bloque, int numNucleo){
                    boolean exito = false;
                    
                    if(numNucleo == 0){ //Si es el nucleo 1
                        if(busDatos.tryAcquire()){
                            try {
                                barrera();
                                barrera();
                            } catch (InterruptedException | BrokenBarrierException ex) {
                                Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            //Empieza ciclo de reloj con posesion del bus
                            if(s_cacheDatosNucleo2.tryAcquire()){
                                try {
                                    barrera();
                                    barrera();
                                } catch (InterruptedException | BrokenBarrierException ex) {
                                    Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                //Empiezo ciclo con cache del nucleo 2
                                if (estaEnCache(direccionMem,1)){
                                    //Si la tiene en cache, revisamos si esta modificado.
                                    if (estaModificado(direccionMem,1)){
                                        //Lo escribe en memoria
                                        int numBloque = direccionMem % 8;
                                        for (int i = 0; i < 4; i++){
                                            memoriaDatos[direccionMem+i] = cacheDatosNucleo2[numBloque][i];
                                        }
                                        //Manda a invalidar ese bloque en la cache del nucleo 2.
                                        BloqueAInvalidar bloqueInvalido = new BloqueAInvalidar((direccionMem/4),1);
                                        bloquesAInvalidar.add(bloqueInvalido);
                                    }
                                    //Si no esta modificado, esta compartido
                                }
                                s_cacheDatosNucleo2.release();
                                int numBloque = direccionMem % 8;
                                for (int i = 0; i < 4; i++){
                                    cacheDatosNucleo1[numBloque][i] = memoriaDatos[direccionMem+i];
                                }
                                cacheDatosNucleo1[numBloque][4] = bloque;
                                cacheDatosNucleo1[numBloque][5] = 1;
                                //Espera los ciclos de reloj que dura transmitiendo
                                for(int k =0 ; k<(4*(b+m+b));++k){
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                                exito = true;
                            }
                            busDatos.release();
                        }
                    }
                    else { //Si es el nucleo 2
                        if(busDatos.tryAcquire()){
                            try {
                                barrera();
                                barrera();
                            } catch (InterruptedException | BrokenBarrierException ex) {
                                Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            //Empieza ciclo de reloj con posesion del bus
                            if(s_cacheDatosNucleo1.tryAcquire()){
                                try {
                                    barrera();
                                    barrera();
                                } catch (InterruptedException | BrokenBarrierException ex) {
                                    Logger.getLogger(Salida.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                //Empiezo ciclo con cache del nucleo 1
                                if (estaEnCache(direccionMem,0)){
                                    //Si la tiene en cache, revisamos si esta modificado.
                                    if (estaModificado(direccionMem,0)){
                                        //Lo escribe en memoria
                                        int numBloque = direccionMem % 8;
                                        for (int i = 0; i < 4; i++){
                                            memoriaDatos[direccionMem+i] = cacheDatosNucleo1[numBloque][i];
                                        }
                                        //Manda a invalidar ese bloque en la cache del nucleo 1.
                                        BloqueAInvalidar bloqueInvalido = new BloqueAInvalidar((direccionMem/4),0);
                                        bloquesAInvalidar.add(bloqueInvalido);
                                    }
                                    //Si no esta modificado, esta compartido
                                }
                                s_cacheDatosNucleo1.release();
                                int numBloque = direccionMem % 8;
                                for (int i = 0; i < 4; i++){
                                    cacheDatosNucleo2[numBloque][i] = memoriaDatos[direccionMem+i];
                                }
                                cacheDatosNucleo2[numBloque][4] = bloque;
                                cacheDatosNucleo2[numBloque][5] = 1;
                                //Espera los ciclos de reloj que dura transmitiendo
                                for(int k =0 ; k<(4*(b+m+b));++k){
                                    try {
                                        barrera();
                                        barrera();
                                    } catch (InterruptedException | BrokenBarrierException ex) {
                                        Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                                    }
                                }
                                exito = true;
                            }
                            busDatos.release();
                        }
                    }
                    
                    return exito;
                    
                }

                /**
                 * Extrae la instruccion de la cache correspondiente
                 * @param PC
                 * @param bloque bloque de cache donde se encuentra la instruccion
                 * @param self nucleo que desea obtener la instruccion
                 * @return 
                 */
                private int[] obtenerInstruccion(int PC, int bloque ,int self){
                    int numPalabra;
                    numPalabra = (PC%16)/4;
                    int fila = bloque%8;
                    //System.out.println("Fila"+fila);
                    int[] palabra = new int[4] ;
                    int i = 0;
                    if(self == 0){ //Es el Nucleo 1
                        //System.arraycopy(cacheInstruccionesNucleo1[bloque], numPalabra, palabra, 0, 4);
                        for(int columna = (numPalabra*4); columna < ((numPalabra*4)+4); ++columna,++i){
                            palabra[i] = cacheInstruccionesNucleo1[fila][columna];
                            //System.out.print(cacheInstruccionesNucleo1[fila][columna]);
                        }           
                    }
                    else{
                        //System.arraycopy(cacheInstruccionesNucleo2[bloque], numPalabra, palabra, 0, 4);
                        for(int columna = (numPalabra*4); columna < ((numPalabra*4)+4); ++columna,++i){
                            palabra[i] = cacheInstruccionesNucleo2[fila][columna];
                            //System.out.print(cacheInstruccionesNucleo2[fila][columna]);
                        }  
                    }
                    //System.out.println();
                    return palabra;
                }


                /**
                 * 
                 * @param instruccion instruccion a ejecutar
                 * @param nucleo 
                 */
                public  void  ejecutarInstruccion(int [] instruccion, int nucleo) throws IOException{

                    if(nucleo == 0){                       

                        switch(instruccion[0]){
                            case 8:
                               //System.out.println("Instruccion: "+instruccion[0]+" "+instruccion[1]+" "+instruccion[2]+" "+instruccion[3]);
                                registrosNucleo1[instruccion[2]] = registrosNucleo1[instruccion[1]]+instruccion[3];

                                break;
                            case 32:
                                registrosNucleo1[instruccion[3]] = registrosNucleo1[instruccion[1]]+registrosNucleo1[instruccion[2]];
                                break;
                            case 34:
                                registrosNucleo1[instruccion[3]] = registrosNucleo1[instruccion[1]]-registrosNucleo1[instruccion[2]];
                                //escribirEnArchivo(verRegistros(1));
                                break;
                            case 12:
                                registrosNucleo1[instruccion[3]] = registrosNucleo1[instruccion[1]]*registrosNucleo1[instruccion[2]];
                                break;
                            case 14:
                                registrosNucleo1[instruccion[3]] = registrosNucleo1[instruccion[1]]/registrosNucleo1[instruccion[2]];
                                break;
                            case 35:
                                int bloque = 0 ;// por que se tiene que enviar esto?, no se puede calcular en el metodo el numero de bloque
                                load( nucleo, instruccion, bloque );
                            case 4:
                                if(registrosNucleo1[instruccion[1]]==0){
                                    PCN1 += (4*instruccion[3]);
                                }
                                break;
                            case 5:
                                if(registrosNucleo1[instruccion[1]]!=0){
                                    PCN1 += (4*instruccion[3]);
                                }
                                break;
                            case 3:
                                registrosNucleo1[31] = PCN1;
                                PCN1= PCN1+instruccion[3];
                                break;
                            case 2:
                                PCN1 = registrosNucleo1[instruccion[1]];
                                break;
                            case 63:
                                System.out.println("Se termina de ejecutar el hilo");
                                this.miQuantum = QuantumIngresado+1;
                                /// imprimir registros para verificacion
                                //escribirEnArchivo("Hilo "+hiloN1);
                                escribirEnArchivo(verRegistros(0));
                                escribirEnArchivo("Tamano cola "+colaContextos.size());
                                if(hayHilosEnCola()){
                                    traerSiguenteHilo(0);
                                }
                                else{
                                    estaOcupadoN1 = false;
                                    this.estoyOcupado = false;
                                }

                                break;
                            default:
                                System.out.println("Fallo al ejecutar instruccion "+instruccion[0]);
                        }
                       // escribirEnArchivo(verRegistros(0));

                    }
                    else{
                        switch(instruccion[0]){
                            case 8:
                                registrosNucleo2[instruccion[2]] = registrosNucleo2[instruccion[1]]+instruccion[3];
                                break;
                            case 32:
                                registrosNucleo2[instruccion[3]] = registrosNucleo2[instruccion[1]]+registrosNucleo2[instruccion[2]];
                                break;
                            case 34:
                                registrosNucleo2[instruccion[3]] = registrosNucleo2[instruccion[1]]-registrosNucleo2[instruccion[2]];
                                break;
                            case 12:
                                registrosNucleo2[instruccion[3]] = registrosNucleo2[instruccion[1]]*registrosNucleo2[instruccion[2]];
                                break;
                            case 14:
                                registrosNucleo2[instruccion[3]] = registrosNucleo2[instruccion[1]]/registrosNucleo2[instruccion[2]];
                                break;
                            case 4:
                                if(registrosNucleo2[instruccion[1]]==0){
                                    PCN2 += (4*instruccion[3]);
                                }
                                break;
                            case 5:
                                if(registrosNucleo2[instruccion[1]]!=0){
                                    PCN2 += (4*instruccion[3]);
                                }
                                break;
                            case 3:
                                registrosNucleo2[31] = PCN2;
                                PCN2+=instruccion[3];
                                break;
                            case 2:
                                PCN2 = registrosNucleo2[instruccion[1]];
                                break;
                            case 63:
                                System.out.println("Se termina de ejecutar el hilo");
                                this.miQuantum = QuantumIngresado+1;
                                /// imprimir registros para verificacion
                                //escribirEnArchivo("Hilo "+hiloN2);
                                escribirEnArchivo(verRegistros(1));
                                escribirEnArchivo("Tamano cola "+colaContextos.size());
                                if(hayHilosEnCola()){
                                    traerSiguenteHilo(1);
                                }else{
                                    estaOcupadoN2 = false;
                                    this.estoyOcupado = false;
                                }

                                /// llamar a siguiente proceso en el proximo ciclo de reloj
                                break;
                            default:
                                System.out.println("Fallo al ejecutar instruccion "+instruccion[0]);
                        }
                    }
                    this.miQuantum--;

                }


                    /**
                     * Escribe en un archivo el string que recibe
                     * @param str
                     * @throws IOException 
                     */
                    public void escribirEnArchivo(String str) throws IOException {
                        int nucleo = Integer.parseInt(this.getName());
                        if(nucleo == 0){
                            escribir1.append(str+"\n");//para escribir en el archivo  
                        }
                        else{
                            escribir2.append(str+"\n");//para escribir en el archivo
                        }
                    }
                    public String verInstruccion(int[] instruccion){
                        String instr ="";
                        for(int i=0 ;i <instruccion.length;++i){
                            instr+=""+instruccion[i]+" ";
                        }
                        instr+="\n";
                        return instr;
                    }

                    public String verRegistros(int nucleo){
                        String str ="";
                        if(nucleo==0){
                            for(int i=0;i<registrosNucleo1.length;++i){
                                str+="r"+i+" "+registrosNucleo1[i]+"\n";
                            }
                        }
                        else{
                            for(int i=0;i<registrosNucleo2.length;++i){
                                str+="r"+i+" "+registrosNucleo2[i]+"\n";
                            }
                        }
                        return str;
                    }

                    public void run(){
                        estoyOcupado = true;
                        String str ="";
                        this.miQuantum = QuantumIngresado;
                        try {
                            escribirEnArchivo("Nucleo "+getName());

                            //toda la logica por aqui
                             int numNucleo = Integer.parseInt(this.getName());
                             int [] instruccion;
                            while(estaOcupadoN1 || estaOcupadoN2){
                                
                                
                                if(estoyOcupado){
                                    if (numNucleo == 0){
                                        IRN1 = PCN1;
                                        System.out.println("PCN1 "+PCN1);
                                        int bloque = PCN1/16;
                                        str+="PC "+PCN1+" Reloj "+clock+"\nBloque "+bloque;
                                        escribirEnArchivo(str);str="";
                                        PCN1 +=4;
                                        if(!estaEnCache(bloque, numNucleo)){
                                            System.out.println("Hay fallo de cache con bloque "+bloque+" PC "+IRN1);
                                            escribirEnArchivo("Hay fallo de cache con bloque "+bloque+" PC "+IRN1);
                                            resolverFalloCache(IRN1,bloque,numNucleo); 
                                            //escribirEnArchivo(obtenerCache(0));
                                        }
                                        instruccion = obtenerInstruccion(IRN1, bloque,0);
                                        escribirEnArchivo("Instruccion "+verInstruccion(instruccion));
                                        ejecutarInstruccion(instruccion,0);
                                        escribirEnArchivo(str+="Quantum "+this.miQuantum);str="";


                                    }else{
                                        IRN2 = PCN2;
                                        System.out.println("PCN2 "+PCN2);
                                        int bloque = PCN2/16;
                                        str+="PC "+PCN2+" Reloj "+clock+"\nBloque "+bloque;
                                        escribirEnArchivo(str);str="";
                                        PCN2 +=4;
                                        if(!estaEnCache(bloque, numNucleo)){
                                            System.out.println("Hay fallo de cache con bloque "+bloque+" PC "+IRN1);
                                            escribirEnArchivo("Hay fallo de cache con bloque "+bloque);
                                            resolverFalloCache(IRN2,bloque,numNucleo); 
                                            //escribirEnArchivo(obtenerCache(1));
                                        }
                                        instruccion = obtenerInstruccion(IRN2, bloque,1);
                                        escribirEnArchivo("Instruccion "+verInstruccion(instruccion));
                                        ejecutarInstruccion(instruccion,1);
                                        escribirEnArchivo(str+="Quantum "+this.miQuantum);str="";

                                    }
                                    if(this.miQuantum == 0){
                                        //escribirEnArchivo(str+="Cambio de contexto "+this.miQuantum);str="";
                                        cambioDeContexto(Integer.parseInt(this.getName()));
                                        this.miQuantum = QuantumIngresado;
                                    }
                                }
                                try {
                                    System.out.println("Llegue a la barrera");
                                    barrera();
                                    barrera();
                                } catch (InterruptedException | BrokenBarrierException ex) {
                                    Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                System.out.println(""+estoyOcupado);
                            }
                            escribir1.close();
                            bw1.close();
                            escribir2.close();
                            bw2.close();
                        } catch (IOException ex) {
                            Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
               });
            }

            while(estaOcupadoN1 || estaOcupadoN2){
                try {
                    System.out.println("Llegue a la barrera");
                    barrera();
                    ++clock;
                    invalidarBloques();
                    System.out.println("Actualizar reloj...");
                    publish(clock);
                    if(modoLento){
                        Thread.sleep(100);
                    }
                    barrera();
                } catch (InterruptedException | BrokenBarrierException ex) {
                    Logger.getLogger(ProyectoArqui.class.getName()).log(Level.SEVERE, null, ex);
                }


            }
            //System.out.println("Ya termine");

            //System.exit(0);
         
            return null;    
        }
        
        @Override
        protected void process(List<Integer> lista){
            Reloj.setText(""+clock);
            //Actualiza Caches
            for(int i =0;i<cacheInstruccionesNucleo1.length;++i){
                for(int j=0; j<cacheInstruccionesNucleo1[i].length;++j){
                    CacheN1.setValueAt(cacheInstruccionesNucleo1[i][j],j,i);
                }
            }
            
            for(int i =0;i<cacheInstruccionesNucleo2.length;++i){
                for(int j=0; j<cacheInstruccionesNucleo2[i].length;++j){
                    CacheN2.setValueAt(cacheInstruccionesNucleo2[i][j],j,i);
                }
            }
            //Carga memoria.
            int n = 0;
            for(int j = 0; j < 40; ++j){
                for(int i = 0; i < 16; ++i,++n){
                    memoriaInstrucciones_view.setValueAt(memoriaInstrucciones[n], j, i);
                    //System.out.print(""+instrucciones[n]);
                }
                //System.out.println();
            }
            
            //Set Registros
            for(int i =0;i<registrosNucleo1.length;++i){
                registrosN1.setValueAt(registrosNucleo1[i],i, 1);
            }    
        
            for(int i =0;i<registrosNucleo2.length;++i){
                registrosN2.setValueAt(registrosNucleo2[i],i, 1);
            }  
        
        }
        
    }
}
